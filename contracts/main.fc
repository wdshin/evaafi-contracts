#pragma version >=0.2.0;
#include "imports/stdlib.fc";
#include "imports/math.fc";
#include "imports/op-codes.fc";
#include "imports/constants.fc";
#include "src/main/get-methods.fc";
#include "src/main/storage.fc";
#include "src/logic.fc";
#include "src/utils.fc";

(cell) calculate_user_init_state(slice sender_address) {
  return begin_cell()
    .store_slice(my_address())
    .store_slice(sender_address)
    .store_ref(begin_cell().end_cell())
    .end_cell(); 
}

(slice) calculate_user_address (cell state_init) {
  return begin_cell().store_uint(4, 3)
    .store_int(workchain(), 8)
    .store_uint(cell_hash(state_init), 256)
    .end_cell()
    .begin_parse();
}

() init_user (slice sender_address) impure {
  cell state_init = calculate_user_init_state(sender_address);
  slice to_wallet_address = calculate_user_address(state_init);
 
  var msg = begin_cell()
              .store_uint(0x18, 6)
              .store_slice(to_wallet_address)
              .store_coins(start_balance)
              .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
              .store_ref(state_init)
              .store_ref(begin_cell().end_cell()); ;; TODO set dict with key:assetaddress and zero values

  send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}

() process_incoming_ton() impure {
  ;; TODO
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  slice sender_address = cs~load_msg_addr();
  var (wc, addr_hash) = parse_std_addr(sender_address);

  if (flags & 1) {
    ;; TODO: Finish logic of on bounce
    ;; on_bounce(in_msg_body, msg_value);
    ;; in theory "throw(0xffff)" will be enougth
		throw(0xffff); 
  }

  (cell meta, cell user_contract_code, cell assets_config, int if_active, slice admin, cell asset_data) = storage::load();

  if (in_msg_body.slice_empty?()) { ;; TON incoming (without comment)
    process_incoming_ton();
    return ();
  }

  int op = in_msg_body~load_uint(32);
  if (op == 0) { ;; TON incoming (with comment)
    process_incoming_ton();
  }

  int query_id = in_msg_body~load_uint(64);

  if (op == op::init_master) {
    var (wc, admin_addr_hash) = parse_std_addr(admin);
    throw_unless(103, addr_hash == admin_addr_hash);
    cell newAssetConfig = in_msg_body~load_ref();
    cell newasset_data = in_msg_body~load_ref();
    storage::save(meta, user_contract_code, newassets_config, if_active, admin, newasset_data);
    return();
  }
  
  if (op == op::init_user) {
    init_user(sender_address); 
    return();
  }
  
  if (op == op::update_price) {
    cell assetName = in_msg_body~load_msg_addr();
    var (assetConfig, is_asset_existing?) = assets_config.udict_get?(256, assetName);
    throw_unless(100, is_asset_existing?);
    slice whiteListedOracle = assets_config~load_msg_addr();
    var (wc, oracle_addr_hash) = parse_std_addr(whiteListedOracle);
    throw_unless(103, addr_hash == oracle_addr_hash);
    var (asset_data_item, _) = asset_data.udict_get?(256, assetName); ;; ?????!! assets_data ??
    int newPrice = in_msg_body~load_uint(64);

    var (_, _, sRate, bRate, total_supply_principal, totalBorrowPrincipal, lastAccural) = unpack_asset_data(asset_data_item);

    cell updatedAsset = pack_asset_data(newPrice, sRate, bRate, total_supply_principal, totalBorrowPrincipal, now());
    ;; todo need to ask if we need now of we can use old lastAccural

    assets_data~dict_set(256, assetName, updatedAsset);
    storage::save(meta, user_contract_code, assets_config, if_active, admin, assets_data);
    return();
  }
  
  if (op == op::update_config) {
    ;;todo update not only asset config but config of entire market (isActive & meta too)
    var (wc, admin_addr_hash) = parse_std_addr(admin);
    throw_unless(103, addr_hash == admin_addr_hash);
    cell newAssetConfig = in_msg_body~load_ref();
    storage::save(meta, user_contract_code, newassets_config, if_active, admin, asset_data);
    return();
  }
  
  if (op == op::withdraw) {
    ;; todo/anyone/to user
  }
  
  if (op == op::transfer_notification) {
    int query_id = in_msg_body~load_uint(64); 
    int coins = in_msg_body~load_coins(); 
    int query_id = in_msg_body~load_uint(64); 
    int from_address = in_msg_body~load_msg_addr(); 
    int jetton_msg_body = in_msg_body~load_msg_addr(); ;; check how we get body here 
    int op_jetton = jetton_msg_body~load_uint(32); 
    int query_id_jetton = jetton_msg_body~load_uint(64); 
    int jetton_token_id = jetton_msg_body~load_uint(32); 
    
    if (op_jetton == op::liquidate) {
      ;; todo/anyone/to user/jetton
    }
    
    if (op_jetton == op::supply) {
      ;; todo/anyone/to user/jetton
    }

    ;; todo bounce user jetton if no op codes / maybe liquidate will be not in transfer_notification
  }

  ;; todo recive native ton ;; without wraps / unwraps

  if (op == op::wrap()) {
    ;; todo logic for wrapping tons 
  }

  if (op == op::unwrap) {
    ;; todo logic for unwrapping tons
  }

  throw(0xffff); 
}

;; todo send to treasure and send from treasure (to cammunicating with jettons) logic or smth
;; todo ton to wTON wrapper
