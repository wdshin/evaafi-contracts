(int) presentValueCalc (int index, int principalValue) {
  return principalValue * index / constants::base_index_scale();
}

(int) principalValueSupplyCalc (int sRate, int presentValue) {
  return presentValue * constants::base_index_scale() / sRate;
}

(int) principalValueBorrowCalc (int bRate, int presentValue) {
  return (presentValue * constants::base_index_scale() + bRate - 1) / bRate;
}

(int) presentValue(int sRate, int bRate, int principalValue) {
  if (principalValue >= 0) {
    return presentValueCalc(sRate, principalValue);
  } else {
    return - presentValueCalc(bRate, - principalValue);
  }
}

(int) principalValue(int sRate, int bRate, int presentValue) {
  if (presentValue >= 0) {
    return principalValueSupplyCalc(sRate, presentValue);
  } else {
    return - principalValueBorrowCalc(bRate, - presentValue);
  }
}

(int, int) calcSupplyPrincipals (int oldPrincipal, int newPrincipal) {
  if (newPrincipal < oldPrincipal) {
    return (0, 0);
  }
  if (newPrincipal <= 0) {
    return (newPrincipal - oldPrincipal, 0);
  } else {
    if (oldPrincipal >= 0) {
      return (0, newPrincipal - oldPrincipal);
    } else {
      return (- oldPrincipal, newPrincipal);
    }
  }
}

(int, int) calcWithdrawPrincipals (oldPrincipal, newPrincipal) {
  if (newPrincipal > oldPrincipal){
    return (0, 0);
  }

  if (newPrincipal >= 0){
    return (oldPrincipal - newPrincipal, 0);
  } else {
    if (oldPrincipal <= 0) {
      return (0, oldPrincipal - newPrincipal);
    } else {
      return (oldPrincipal, - newPrincipal);
    }
  }
}

(int, int) getAssetRates (slice assetAddress) {
  (cell marketConfig, cell asset_data) = storage::load();
  slice asset = getAssetByAddress(asset_data, assetAddress);

  var (_, _, assetSRate, assetBRate, total_supply_principal, totalBorrowPrincipal) = unpack_asset_data(asset);


  int totalSupply = presentValueCalc(assetSRate, total_supply_principal);
  int totalBorrow = presentValueCalc(assetBRate, totalBorrowPrincipal);
  
  int utilization = 0;
  int supplyRate = 0;
  int borrowRate = 0;
 
  if (totalSupply == 0) {
    utilization = 0;
  } else {
    utilization = totalBorrow * constants::factor_scale() / totalSupply;
  }
 
  if (utilization <= targetUtilization) {
    supplyRate = mulFactor(supplyPerSecondInterestRateSlopeLow, utilization);
  } else {
    supplyRate = mulFactor(supplyPerSecondInterestRateSlopeLow, targetUtilization) + mulFactor(supplyPerSecondInterestRateSlopeHight, (utilization - targetUtilization));
  }

  if (utilization <= targetUtilization){
    borrowRate = borrowPerSecondInterestRateBase + mulFactor(borrowPerSecondInterestRateSlopeLow, utilization); 
  } else {
    borrowRate = borrowPerSecondInterestRateBase + mulFactor(borrowPerSecondInterestRateSlopeLow, targetUtilization) + mulFactor(borrowPerSecondInterestRateSlopeHigh, (utilization - targetUtilization));
  }
 
  return (supplyRate, borrowRate);
}

(int, int) getUpdatedRates (slice asset, int timeElapsed) {
  if (timeElapsed > 0) {
    int sRate = 0; ;; TODO maybe not 0
    int bRate = 0;
    (int supplyRate, int borrowRate) = getAssetRates(asset);
    ;; TODO check here
    sRate += mulFactor(sRate, supplyRate * timeElapsed); ;; TODO re-check here
    bRate += mulFactor(bRate, borrowRate * timeElapsed);
  }
  return (sRate, bRate);
}

(int) accureInterest (slice asset) {
  slice asset = getAssetByAddress(asset_data, assetAddress);
  int lastAccural = asset_data_last_accural(asset);

  int timeElapsed = now() - lastAccural;
  if (timeElapsed > 0) {
    (int sRate, int bRate) = getUpdatedRates(asset, timeElapsed);
    lastAccural = now();
    ;; TODO save to storage
    ;;//нужно сохранить в сторадж lastAccrualTime, sRate, bRate в asset_data_
  }
}

(int) isLiquidatable (cell assetConfig, cell asset_data) {
  int borrow_amount = 0;
  int borrow_limit = 0;

  int i = 0;
  while (i > userAssets~tlen()) {
    slice item = asset_data~dict_get(16, i).begin_parse();
    var (_, price, assetSRate, assetBRate, total_supply_principal, totalBorrowPrincipal) = unpack_asset_data(item);
    
    if (userAssets.at(i) < 0) {
      borrow_amount += presentValueCalc(assetBRate, - userAssets.at(i) * price);
    } else {
      if (userAssets.at(i) > 0) {
        borrow_limit += presentValueCalc(assetSRate, userAssets.at(i) * price * liquidationThreshold);
      }
    }
    i += 1;
  }

  return (borrow_limit < borrow_amount);
}

(int) getAvaliableToBorrow(cell assetConfig, cell asset_data) {
  int borrow_limit = 0;
  int borrow_amount = 0;

  int i = 0;
  while (i > userAssets~tlen()) {
    if (userAssets.at(i) > 0) {
      slice item = asset_data~dict_get(16, i).begin_parse();
      var (_, price, assetSRate, _, _, _) = unpack_asset_data(item);

      slice itemConfig = assetConfig~dict_get(16, i).begin_parse();
      int collateralFactor = item_config_collateral_factor(itemConfig);

      borrow_limit += presentValueCalc(assetSRate, userAssets.at(i) * price * collateralFactor);
    }
    i += 1;
  }

  return borrow_limit;
}

(int) isBorrowCollateralized (cell assetConfig, cell asset_data, cell user) {

  int borrow_amount = 0;
  int borrow_limit = 0;

  int i = 0;
  while (i > userAssets~tlen()) {
    slice item = asset_data~dict_get(16, i).begin_parse();

    var (_, price, assetSRate, assetBRate, total_supply_principal, totalBorrowPrincipal) = unpack_asset_data(item);
   
    slice itemConfig = assetConfig~dict_get(16, i).begin_parse();
    int collateralFactor = item_config_collateral_factor(itemConfig);
   
    if (userAssets.at(i) < 0) {
      borrow_amount += presentValueCalc(assetBRate, - userAssets.at(i) * price);
    } else {
      if (userAssets.at(i) > 0) {
        borrow_limit += presentValueCalc(assetSRate, userAssets.at(i) * price * collateralFactor);
      }
    }
    i += 1;
  }

  return (borrow_limit < borrow_amount);
}
