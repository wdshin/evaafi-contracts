(int) presentValueCalc (int index, int principalValue) {
  return principalValue * index / constants::base_index_scale();
}

(int) principalValueSupplyCalc (int sRate, int presentValue) {
  return presentValue * constants::base_index_scale() / sRate;
}

(int) principalValueBorrowCalc (int bRate, int presentValue) {
  return (presentValue * constants::base_index_scale() + bRate - 1) / bRate;
}

(int) presentValue(int sRate, int bRate, int principalValue) {
  if (principalValue >= 0) {
    return presentValueCalc(sRate, principalValue);
  } else {
    return - presentValueCalc(bRate, - principalValue);
  }
}

(int) principalValue(int sRate, int bRate, int presentValue) {
  if (presentValue >= 0) {
    return principalValueSupplyCalc(sRate, presentValue);
  } else {
    return - principalValueBorrowCalc(bRate, - presentValue);
  }
}

(int, int) calcSupplyPrincipals (int oldPrincipal, int newPrincipal) {
  if (newPrincipal < oldPrincipal) {
    return (0, 0);
  }
  if (newPrincipal <= 0) {
    return (newPrincipal - oldPrincipal, 0);
  } else {
    if (oldPrincipal >= 0) {
      return (0, newPrincipal - oldPrincipal);
    } else {
      return (- oldPrincipal, newPrincipal);
    }
  }
}

(int, int) calcWithdrawPrincipals (oldPrincipal, newPrincipal) {
  if (newPrincipal > oldPrincipal){
    return (0, 0);
  }

  if (newPrincipal >= 0){
    return (oldPrincipal - newPrincipal, 0);
  } else {
    if (oldPrincipal <= 0) {
      return (0, oldPrincipal - newPrincipal);
    } else {
      return (oldPrincipal, - newPrincipal);
    }
  }
}

(int, int) getAssetRates (slice assetAddress) {
  (cell marketConfig, cell assetData) = storage::load();
  slice asset = getAssetByAddress(assetData, assetAddress);
  asset~load_msg_addr();
  asset~load_uint(64);
 
  int assetSRate = asset~load_uint(64);
  int assetBRate = asset~load_uint(64);
  int totalSupplyPrincipal = asset~load_uint(64);
  int totalBorrowPrincipal = asset~load_uint(64);
  int totalSupply = presentValueCalc(assetSRate, totalSupplyPrincipal);
  int totalBorrow = presentValueCalc(assetBRate, totalBorrowPrincipal);
  
  int utilization = 0;
  int supplyRate = 0;
  int borrowRate = 0;
 
  if (totalSupply == 0) {
    utilization = 0;
  } else {
    utilization = totalBorrow * constants::factor_scale() / totalSupply;
  }
 
  if (utilization <= targetUtilization) {
    supplyRate = mulFactor(supplyPerSecondInterestRateSlopeLow, utilization);
  } else {
    supplyRate = mulFactor(supplyPerSecondInterestRateSlopeLow, targetUtilization) + mulFactor(supplyPerSecondInterestRateSlopeHight, (utilization - targetUtilization));
  }

  if (utilization <= targetUtilization){
    borrowRate = borrowPerSecondInterestRateBase + mulFactor(borrowPerSecondInterestRateSlopeLow, utilization); 
  } else {
    borrowRate = borrowPerSecondInterestRateBase + mulFactor(borrowPerSecondInterestRateSlopeLow, targetUtilization) + mulFactor(borrowPerSecondInterestRateSlopeHigh, (utilization - targetUtilization));
  }
 
  return (supplyRate, borrowRate)
}

(int, int) getUpdatedRates (slice asset, int timeElapsed) {
  if (timeElapsed > 0) {
    int sRate = 0; ;; TODO maybe not 0
    int bRate = 0;
    (int supplyRate, int borrowRate) = getAssetRates(asset);
    ;; TODO check here
    sRate += mulFactor(sRate, supplyRate * timeElapsed); ;; TODO re-check here
    bRate += mulFactor(bRate, borrowRate * timeElapsed);
  }
  return (sRate, bRate);
}

(int) accureInterest (slice asset) {
  slice asset = getAssetByAddress(assetData, assetAddress);
  asset~load_msg_addr();
  asset~load_uint(64);
 
  asset~load_uint(64);
  asset~load_uint(64);
  asset~load_uint(64);
  asset~load_uint(64);
  int lastAccural = asset~load_uint(64);
  int timeElapsed = now() - lastAccural;
  if (timeElapsed > 0) {
    (int sRate, int bRate) = getUpdatedRates(asset, timeElapsed);
    lastAccural = now();
    ;; TODO save to storage
    ;;//нужно сохранить в сторадж lastAccrualTime, sRate, bRate в assetData_
  }
}

(int) isLiquidatable (cell assetConfig, cell assetData) {
  int borrow_amount = 0;
  int borrow_limit = 0;

  int i = 0;
  while (i > userAssets~tlen()) {
    slice item = assetData~dict_get(16, i).begin_parse();
    asset~load_msg_addr();
    int price = asset~load_uint(64);
    int assetSRate = asset~load_uint(64);
    int assetBRate = asset~load_uint(64);
    int totalSupplyPrincipal = asset~load_uint(64);
    int totalBorrowPrincipal = asset~load_uint(64);
    
    if (userAssets.at(i) < 0) {
      borrow_amount += presentValueCalc(assetBRate, - userAssets.at(i) * price);
    } else {
      if (userAssets.at(i) > 0) {
        borrow_limit += presentValueCalc(assetSRate, userAssets.at(i) * price * liquidationThreshold);
      }
    }
    i += 1;
  }

  return (borrow_limit < borrow_amount);
}

(int) getAvaliableToBorrow(cell assetConfig, cell assetData) {
  int borrow_limit = 0;
  int borrow_amount = 0;

  int i = 0;
  while (i > userAssets~tlen()) {
    if (userAssets.at(i) > 0) {
      slice item = assetData~dict_get(16, i).begin_parse();
      asset~load_msg_addr();
      int price = asset~load_uint(64);
      int assetSRate = asset~load_uint(64);

      slice itemConfig = assetConfig~dict_get(16, i).begin_parse();
      itemConfig~load_msg_addr();
      itemConfig~load_msg_addr();
      itemConfig~load_uint(8);
      cell itemConfigData = itemConfig~load_ref();
      int collateralFactor = itemConfigData~load_uint(16);

      borrow_limit += presentValueCalc(assetSRate, userAssets.at(i) * price * collateralFactor);
    }
    i += 1;
  }

  return borrow_limit;
}

(int) isBorrowCollateralized (cell assetConfig, cell assetData, cell user) {

  int borrow_amount = 0;
  int borrow_limit = 0;

  int i = 0;
  while (i > userAssets~tlen()) {
    slice item = assetData~dict_get(16, i).begin_parse();
    asset~load_msg_addr();
    int price = asset~load_uint(64);
    int assetSRate = asset~load_uint(64);
    int assetBRate = asset~load_uint(64);
    int totalSupplyPrincipal = asset~load_uint(64);
    int totalBorrowPrincipal = asset~load_uint(64);
   
    slice itemConfig = assetConfig~dict_get(16, i).begin_parse();
    itemConfig~load_msg_addr();
    itemConfig~load_msg_addr();
    itemConfig~load_uint(8);
    cell itemConfigData = itemConfig~load_ref();
    int collateralFactor = itemConfigData~load_uint(16);
   
    if (userAssets.at(i) < 0) {
      borrow_amount += presentValueCalc(assetBRate, - userAssets.at(i) * price);
    } else {
      if (userAssets.at(i) > 0) {
        borrow_limit += presentValueCalc(assetSRate, userAssets.at(i) * price * collateralFactor);
      }
    }
    i += 1;
  }

  return (borrow_limit < borrow_amount);
}
