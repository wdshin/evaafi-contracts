(int) getAccountAssetBalance (slice asset_address, tuple rates_tuple) method_id {
  return get_account_asset_balance(asset_address, rates_tuple);
}

(cell) getAccountBalances (cell asset_dynamics_collection) method_id {
  (slice master, slice user, cell user_principals) = storage::load();
  (int asset_address, slice asset_value_principal_packed, int flag) = user_principals.udict_get_min?(256);
  int asset_value_principal = asset_value_principal_packed~load_principal();
  cell account_balances = new_dict();
  while (flag) {
    int asset_value_principal = asset_value_principal_packed~load_principal();
    var (asset_dynamics, _) = asset_dynamics_collection.udict_get?(256, asset_address);
    var (price, asset_s_rate, asset_b_rate, total_supply_principal, total_borrow_principal, last_accural, token_balance) = unpack_asset_dynamics(asset_dynamics);
    tuple rates_tuple = empty_tuple();
    rates_tuple~tpush(asset_s_rate); ;;todo tests / maybe we need to change to load_sb_rate or smth
    rates_tuple~tpush(asset_b_rate);
    int balance = get_account_asset_balance(calc_address_from_hash(asset_address), rates_tuple);
    account_balances~udict_set(256, asset_address, begin_cell().store_uint(balance, 64).end_cell().begin_parse()); ;; todo tests
    (asset_address, asset_value_principal_packed, flag) = user_principals.udict_get_next?(256, asset_address);
  }
  return (begin_cell().store_dict(account_balances).end_cell());
}

(int) getAvailableToBorrow (cell asset_config_collection, cell asset_dynamics_collection) method_id {
 return get_avaliable_to_borrow(asset_config_collection, asset_dynamics_collection);
}

(int) test () method_id {
  return (2);
}
