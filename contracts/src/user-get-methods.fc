(int) getAccountAssetBalance (slice asset_address, tuple rates_tuple) method_id {
  return get_account_asset_balance(asset_address, rates_tuple);
}

(cell) getAccountBalances (cell asset_dynamics_collection) method_id {
  (slice master, slice user, cell user_principals) = storage::load();
  (int asset_address, slice asset_value_principal_packed, int flag) = user_principals.udict_get_min?(256);
  int asset_value_principal = asset_value_principal_packed~load_uint(64);
  cell account_balances = new_dict();
  while (flag) {
    int asset_value_principal = asset_value_principal_packed~load_uint(64);
    var (asset_dynamics, _) = asset_dynamics_collection.udict_get?(256, asset_address);
    var (price, asset_s_rate, asset_b_rate, total_supply_principal, total_borrow_principal, last_accural) = unpack_asset_dynamics(asset_dynamics);
    tuple rates_tuple = empty_tuple();
    rates_tuple~tpush(asset_s_rate);
    rates_tuple~tpush(asset_b_rate);
    ~dump(rates_tuple); ;; todo tests
    dict~udict_set(256, asset_address, get_account_asset_balance(asset_address, rates_tuple)); ;; todo tests
    (int asset_address, slice asset_value_principal_packed, int flag) =  user_principals.udict_get_next?(256, asset_address);
  }
  return (dict);
}

(int) getAvailableToBorrow (cell asset_config, cell asset_dynamics_collection) method_id {
 return get_avaliable_to_borrow(asset_config, asset_dynamics_collection);
}

(int) test () method_id {
  return (2);
}
