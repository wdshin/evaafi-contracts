(int) getAccountAssetBalance (slice asset_address, tuple rates_tuple) method_id {
  return get_account_asset_balance(asset_address, rates_tuple);
}

(cell) getAccountBalances (cell asset_data) method_id {
  (slice master, slice user, cell user_principals) = storage::load();
  (int asset_address, slice asset_value_principal_packed, int flag) = user_principals.udict_get_min?(256);
  int asset_value_principal = asset_value_principal_packed~load_uint(64);
  cell account_balances = new_dict();
  while (flag) {
    int asset_value_principal = asset_value_principal_packed~load_uint(64);
    var (asset_data_item, _) = asset_data.udict_get?(256, asset_address);
    var (price, asset_s_rate, asset_b_rate, total_supply_principal, total_borrow_principal, last_accural) = unpack_asset_data(asset_data_item);
    tuple rates_tuple = empty_tuple();
    rates_tuple~tpush(asset_s_rate);
    rates_tuple~tpush(asset_b_rate);
    ~dump(rates_tuple); ;; todo tests
    int balance = get_account_asset_balance(calc_address_from_hash(asset_address), rates_tuple);
    account_balances~udict_set(256, asset_address, begin_cell().store_uint(balance, 64).end_cell().begin_parse()); ;; todo tests
    (int asset_address, slice asset_value_principal_packed, int flag) =  user_principals.udict_get_next?(256, asset_address);
  }
  return (account_balances);
}

(int) getAvailableToBorrow (cell asset_config, cell asset_data) method_id {
 return get_avaliable_to_borrow(asset_config, asset_data);
}

(int) test () method_id {
  return (2);
}
