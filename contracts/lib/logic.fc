#include "../imports/stdlib.fc";
#include "../imports/constants.fc";
#include "storage.fc";

(int) presentValueCalc (int index, int principalValue) {
  return principalValue * index / constants::base_index_scale();
}

(int) principalValueSupplyCalc (int sRate, int presentValue) {
  return presentValue * constants::base_index_scale() / sRate;
}

(int) principalValueBorrowCalc (int bRate, int presentValue) {
  return (presentValue * constants::base_index_scale() + bRate - 1) / bRate;
}

(int) presentValue(int sRate, int bRate, int principalValue) {
  if (principalValue >= 0) {
    return presentValueCalc(sRate, principalValue);
  } else {
    return - presentValueCalc(bRate, - principalValue);
  }
}

(int) principalValue(int sRate, int bRate, int presentValue) {
  if (presentValue >= 0) {
    return principalValueSupplyCalc(sRate, presentValue);
  } else {
    return - principalValueBorrowCalc(bRate, - presentValue);
  }
}

(int, int) calcSupplyPrincipals (int oldPrincipal, int newPrincipal) {
  if (newPrincipal < oldPrincipal) {
    return (0, 0);
  }
  if (newPrincipal <= 0) {
    return (newPrincipal - oldPrincipal, 0);
  } else {
    if (oldPrincipal >= 0) {
      return (0, newPrincipal - oldPrincipal);
    } else {
      return (- oldPrincipal, newPrincipal);
    }
  }
}

(int, int) calcWithdrawPrincipals (oldPrincipal, newPrincipal) {
  if (newPrincipal > oldPrincipal){
    return (0, 0);
  }

  if (newPrincipal >= 0){
    return (oldPrincipal - newPrincipal, 0);
  } else {
    if (oldPrincipal <= 0) {
      return (0, oldPrincipal - newPrincipal);
    } else {
      return (oldPrincipal, - newPrincipal);
    }
  }
}

(int, int) getAssetRates (slice asset) {
  (cell marketConfig, cell assetData) = storage::load();
  ;;assetData
  ;;  uint totalSupply_ = presentValueCalc(assetData.asset.sRate, assetData.asset.totalSupplyPrincipal);
  ;;      uint totalBorrow_ = presentValueCalc(assetData.asset.bRate, assetData.asset.totalBorrowPrincipal);
  ;; int totalSupply = presentValueCalc(asset)
  int utilization = 0;
  int supplyRate = 0;
  int borrowRate = 0;
 
  if (totalSupply == 0) {
    utilization = 0;
  } else {
    utilization = totalBorrow * constants::factor_scale() / totalSupply;
  }
 
  if (utilization <= targetUtilization) {
    supplyRate = mulFactor(supplyPerSecondInterestRateSlopeLow, utilization);
  } else {
    supplyRate = mulFactor(supplyPerSecondInterestRateSlopeLow, targetUtilization) + mulFactor(supplyPerSecondInterestRateSlopeHight, (utilization - targetUtilization));
  }

  if (utilization <= targetUtilization){
    borrowRate = borrowPerSecondInterestRateBase + mulFactor(borrowPerSecondInterestRateSlopeLow, utilization); 
  } else {
    borrowRate = borrowPerSecondInterestRateBase + mulFactor(borrowPerSecondInterestRateSlopeLow, targetUtilization) + mulFactor(borrowPerSecondInterestRateSlopeHigh, (utilization - targetUtilization));
  }
  return (supplyRate, borrowRate)
}

(int) accureInterest (slice asset) {

}
