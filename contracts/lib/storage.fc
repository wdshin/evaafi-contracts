#include "../imports/stdlib.fc";

(cell) storage::serializeAssetsConfig () inline {
  ;;assetsConfig: [
  ;;  ...,
  ;;  {
  ;;    asset: address,
  ;;    oracle: address,
  ;;    decimals: uint8,
  ;;    collateralFactor: uint16,
  ;;    liquidationThreshold: uint16,
  ;;    liquidationPenalty: uint16,
  ;;    baseBorrowRate: uint64, ;; ? maybe 16
  ;;    borrowRateSLopeLow: uint64,
  ;;    borrowRateSlopeHigh: uint64,
  ;;    supplyRateSlopeLow: uint64,
  ;;    supplyRateSlopeHigh: uint64,
  ;;    targetUtilization: uint64
  ;;  },
  ;;  ...
  ;;]
  
  slice assetTonConfig = begin_cell()
      .store_slice(my_address())
      .store_slice(my_address())
      .store_uint(8, 8)
      .store_ref(begin_cell()
          .store_uint(8300, 16)
          .store_uint(9000, 16)
          .store_uint(500, 16)
          .store_uint(15854895991, 64)
          .store_uint(25000000000, 64)
          .store_uint(187500000000, 64)
          .store_uint(10000000000, 64)
          .store_uint(100000000000, 64)
          .store_uint(800000000000000000, 64)
        .end_cell())
    .end_cell().begin_parse();
  
  slice assetUsdtConfig = begin_cell()
      .store_slice(my_address())
      .store_slice(my_address())
      .store_uint(6, 8)
      .store_ref(begin_cell()
          .store_uint(8000, 16)
          .store_uint(8500, 16)
          .store_uint(700, 16)
          .store_uint(20611364789, 64)
          .store_uint(32500000000, 64)
          .store_uint(243750000000, 64)
          .store_uint(13000000000, 64)
          .store_uint(130000000000, 64)
          .store_uint(900000000000000000, 64)
        .end_cell())
    .end_cell().begin_parse();
  
  cell assetsConfig = new_dict();

  assetsConfig~udict_set(16, 0, assetTonConfig);
  assetsConfig~udict_set(16, 1, assetUsdtConfig);

  return assetsConfig;
}

(cell) storage::serializeAssetsData () inline {
  ;;assetsData: [
  ;;  ...,
  ;;  {
  ;;    asset: address,
  ;;    sRate: uint64,
  ;;    bRate: uint64,
  ;;    totalSupply: uint64,
  ;;    totalBorrow: uint64,
  ;;    lastAccural: timestamp
  ;;  },
  ;;  ...
  ;;]
  
  slice assetTonData = begin_cell()
      .store_slice(my_address())
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
    .end_cell().begin_parse();

  slice assetUsdtData = begin_cell()
      .store_slice(my_address())
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
    .end_cell().begin_parse();
  
  cell assetsData = new_dict();

  assetsData~udict_set(16, 0, assetTonData);
  assetsData~udict_set(16, 1, assetUsdtData);

  return assetsData;
}

() storage::save () impure inline {
  ;;poolStorage: {
  ;;  config: {
  ;;    assetsConfig: [],
  ;;    ifActive: bool,
  ;;    admin: address
  ;;  },
  ;;  assetsData: [],
  ;;}

  cell serializedAssetsConfig = storage::serializeAssetsConfig();
  cell serializedAssetsData = storage::serializeAssetsData();

  cell data = begin_cell()
    .store_ref(
      begin_cell()
        .store_ref(serializedAssetsConfig)
        .store_uint(-1, 8)
        .store_slice(my_address())
      .end_cell())
    .store_ref(serializedAssetsData)
  .end_cell();

  set_data(data);
}

(cell, cell) storage::load() inline {
  slice ds = get_data().begin_parse();
  cell marketConfig = ds~load_ref();
  cell assetData = ds~load_ref();
  return (marketConfig, assetData);
}

