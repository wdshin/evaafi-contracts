;;import '.math.fc'
#include "../imports/stdlib.fc";

(cell) storage::serializeAssetsConfig () inline {
  ;;assetsConfig: [
  ;;  ...,
  ;;  {
  ;;    asset: address,
  ;;    oracle: address,
  ;;    decimals: uint8,
  ;;    collateralFactor: uint16,
  ;;    liquidationThreshold: uint16,
  ;;    liquidationPenalty: uint16,
  ;;    baseBorrowRate: uint64, ;; ? maybe 16
  ;;    borrowRateSLopeLow: uint64,
  ;;    borrowRateSlopeHigh: uint64,
  ;;    supplyRateSlopeLow: uint64,
  ;;    supplyRateSlopeHigh: uint64,
  ;;    targetUtilization: uint64
  ;;  },
  ;;  ...
  ;;]

  ;;slice assetTonConfig = begin_cell()
  ;;    .store_slice(assetAddress)
  ;;    .store_slice(oracleAddress)
  ;;    .store_uint(decimals, 8)
  ;;    .store_uint(collateralFactor, 16)
  ;;    .store_uint(liquidationThreshold, 16)
  ;;    .store_uint(baseBorrowRate, 16)
  ;;    .store_uint(borrowRateSlopeLow,16)
  ;;    .store_uint(borrowRateSlopeHigh,16)
  ;;    .store_uint(supplyRateSlopeLow,16)
  ;;    .store_uint(supplyRateSlopeHigh,16)
  ;;  .end_cell()
  
  slice assetTonConfig = begin_cell()
      .store_slice(my_address())
      .store_slice(my_address())
      .store_uint(8, 8)
      .store_ref(begin_cell()
          .store_uint(8300, 16)
          .store_uint(9000, 16)
          .store_uint(500, 16)
          .store_uint(15854895991, 64)
          .store_uint(25000000000, 64)
          .store_uint(187500000000, 64)
          .store_uint(10000000000, 64)
          .store_uint(100000000000, 64)
          .store_uint(800000000000000000, 64)
        .end_cell())
    .end_cell().begin_parse();
  
  slice assetUsdtConfig = begin_cell()
      .store_slice(my_address())
      .store_slice(my_address())
      .store_uint(6, 8)
      .store_ref(begin_cell()
          .store_uint(8000, 16)
          .store_uint(8500, 16)
          .store_uint(700, 16)
          .store_uint(20611364789, 64)
          .store_uint(32500000000, 64)
          .store_uint(243750000000, 64)
          .store_uint(13000000000, 64)
          .store_uint(130000000000, 64)
          .store_uint(900000000000000000, 64)
        .end_cell())
    .end_cell().begin_parse();
  
  cell assetsConfig = new_dict();

  assetsConfig~udict_set(16, 0, assetTonConfig);
  assetsConfig~udict_set(16, 1, assetUsdtConfig);

  return assetsConfig;
}

(cell) storage::serializeAssetsData () inline {
  ;;assetsData: [
  ;;  ...,
  ;;  {
  ;;    asset: address,
  ;;    sRate: uint64,
  ;;    bRate: uint64,
  ;;    totalSupply: uint64,
  ;;    totalBorrow: uint64,
  ;;    lastAccural: timestamp
  ;;  },
  ;;  ...
  ;;]
  
  slice assetTonData = begin_cell()
      .store_slice(my_address())
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
    .end_cell().begin_parse();

  slice assetUsdtData = begin_cell()
      .store_slice(my_address())
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
      .store_uint(0, 64)
    .end_cell().begin_parse();
  
  cell assetsData = new_dict();

  assetsData~udict_set(16, 0, assetTonData);
  assetsData~udict_set(16, 1, assetUsdtData);

  return assetsData;
}

;;(cell) storage::serializeUsersSupplies () inline {
;;  ;;usersSupplies: [
;;  ;; ...,
;;  ;; address(as key): [btcTotalAmount, ethTotalAmount, ...]
;;  ;; ...
;;  ;;]
;;
;;  ;;tuple user1Supplies = null();
;;  ;;tuple user2Supplies = null();
;;  ;;tuple user3Supplies = null();
;;
;;  cell user1Supplies =  new_dict();
;;  user1Supplies~udict_set(16, 0, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;  user1Supplies~udict_set(16, 1, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;  
;;  cell user2Supplies = new_dict();
;;  user2Supplies~udict_set(16, 0, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;  user2Supplies~udict_set(16, 1, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;
;;  cell user3Supplies =  new_dict();
;;  user3Supplies~udict_set(16, 0, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;  user3Supplies~udict_set(16, 1, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;  
;;  cell usresSupplies = new_dict();
;;  
;;  usresSupplies~udict_set(64, 0, user1Supplies);
;;  usresSupplies~udict_set(64, 1, user2Supplies);
;;  usresSupplies~udict_set(64, 2, user3Supplies);
;;
;;  return usresSupplies;
;;}
;;
;;(cell) storage::serializeUsersBorrows () inline {
;;  ;;usersBorrows: [
;;  ;; ...,
;;  ;; address(as key): [btcTotalAmount, ethTotalAmount, ...]
;;  ;; ...
;;  ;;]
;;  cell user1Borrows = begin_cell().end_cell();
;;  user1Borrows~udict_set(16, 0, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;  user1Borrows~udict_set(16, 1, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;  
;;  cell user2Borrows = begin_cell().end_cell();
;;  user2Borrows~udict_set(16, 0, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;  user2Borrows~udict_set(16, 1, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;
;;  cell user3Borrows = begin_cell().end_cell();
;;  user3Borrows~udict_set(16, 0, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;  user3Borrows~udict_set(16, 1, begin_cell().store_uint(0, 64).end_cell().begin_parse());
;;  
;;  cell usresBorrows = begin_cell().end_cell();
;;  
;;  usresBorrows~udict_set(64, 0, user1Borrows);
;;  usresBorrows~udict_set(64, 1, user2Borrows);
;;  usresBorrows~udict_set(64, 2, user3Borrows);
;;
;;  return usresBorrows;
;;}

() storage::save () impure inline {
  ;;poolStorage: {
  ;;  config: {
  ;;    assetsConfig: [],
  ;;    ifActive: bool,
  ;;    admin: address
  ;;  },
  ;;  data: {
  ;;    assetsData: [],
  ;;    usersSupplies: [],
  ;;    userBorrows: []
  ;;  }
  ;;}
  ;;cell data = begin_cell()
  ;;  .store_ref(
  ;;    begin_cell()
  ;;      .store_ref(serializedAssetsConfig)
  ;;      .store_uint(ifActive)
  ;;      .store_address(admin)
  ;;    .end_cell())
  ;;  .store_ref(
  ;;    begin_cell()
  ;;      .store_ref(serializedAssetsData)
  ;;      .store_ref(serializedUsersSupplies)
  ;;      .store_ref(serializedUsersBorrows)
  ;;    .end_cell())
  ;;.end_cell();

  cell serializedAssetsConfig = storage::serializeAssetsConfig();
  cell serializedAssetsData = storage::serializeAssetsData();
 ;; cell serializedUsersSupplies = serializeUsersSupplies();
 ;; cell serializedUsersBorrows = serializeUsersBorrows();

  cell data = begin_cell()
    .store_ref(
      begin_cell()
        .store_ref(serializedAssetsConfig)
        .store_uint(-1, 8)
        .store_slice(my_address())
      .end_cell())
    .store_ref(
      begin_cell()
        .store_ref(serializedAssetsData)
;;        .store_ref(serializedUsersSupplies)
;;        .store_ref(serializedUsersBorrows)
      .end_cell())
  .end_cell();

  set_data(data);
}

;;(cell, cell) storage::load() inline {
;;  slice ds = get_data().begin_parse();
;;  cell marketConfig = ds~load_ref();
;;  cell assetConfig = ds~load_ref();
;;  cell serializedAssetsData = aassetsConfig~load_ref();
;;  return (marketConfig, serializedAssetsData);
;;}

;;(slice, slice, slice, slice, cell, cell, cell) storage::load_data() inline {
;;        slice ds = get_data().begin_parse();
;;        slice owner_address = ds~load_msg_addr();
;;        slice info = (ds~load_ref()).begin_parse();
;;        cell borrow = ds~load_dict();
;;        cell lend = ds~load_dict();
;;        cell algebra = ds~load_uint(64);
;;        return (owner_address, info~load_msg_addr(), info~load_msg_addr(), info~load_msg_addr(), info~load_msg_addr(), borrow, lend, algebra);
;;}

;;(int) getAssetPrice (slice assetAddress) method_id {
;;  return 2.81 * 10.math::exp(9);
;;}
;;
;;(tuple) getAssetRates (slice assetAddress) method_id  {
;;  tuple result = empty_tuple();
;;  result~tpush(16969 * 10.math::exp(18));
;;  result~tpush(1777 * 10.math::exp(18));
;;  return result;
;;}
;;
;;(int) getAssetReserves (slice assetAddress) method_id {
;;  return 333 * 10.math::exp(18);
;;}
;;
;;(int) getAccontAssetSupply (slice userAddress, slice assetAddress) method_id {
;;  return 119 * 10.math::exp(18);
;;}
;;
;;(int) getAvaliableToBorrow (slice userAddress) method_id {
;;  return 123 * 10.math::exp(18);
;;}
;;
;;(tuple) getAssetTotals (slice assetAddress) method_id {
;;  tuple result = empty_tuple();
;;  result~tpush(188889 * 10.math::exp(18));
;;  result~tpush(155557 * 10.math::exp(18));
;;  return result;
;;}
;;
;;(cell) getConfig () method_id {
;;  ;;(cell marketConfig, cell serializedAssetsData) = store::load();
;; 
;;  cell serializedAssetsConfig = serializeAssetsConfig();
;;  return begin_cell()
;;        .store_ref(serializedAssetsConfig)
;;        .store_uint(-1, 8)
;;        .store_slice(my_address())
;;      .end_cell());
;;}
;;
;;;; TODO one united method for all assets
